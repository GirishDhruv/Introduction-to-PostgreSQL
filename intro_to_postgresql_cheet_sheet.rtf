TO MAKE COMMENTS/NOTES
Commenting/adding notes that aren't part of the query
	•	To comment to the end of the current line, use '--'
	•	To comment between two specific points use '/* ... */' 

Selecting
	•	Select
	▪	SELECT * FROM <table>;        -- return all data (columns and rows) in the table
	•	Aliasing 
	▪	Select <column> as col_alias from <table> as table_alias;  rename your columns and tables so you don't have to type out the full names  NOTE: columns and tables alias names must start with a letter and cannot start with a number 
	▪	EX:as SELECT address as addr FROM users usr;
	•	Limit
	▪	Limit # -- only return # rows
	•	Unique records: Distinct and Group by 
	▪	Group by
	⁃	Group by <column/value>    -- will group identical rows into a single row. Must use raw column name, not alias
	▪	Distinct
	⁃	Distinct <column> -- will only select unique rows of data selected/returned, any duplicate rows are not returned.
	▪	Group By/Order By & column number reference: Refer to the columns selected by the order they are returned instead of the column itself
	⁃	Example: SELECT status, * FROM orders ORDER BY 1 -- status is the first column returned, so this orders by status sac
	•	Ordering the data returned
	▪	Order by <column/value>     -- return results ordered by the indicated value. Must use raw column name, not alias
	⁃	By default order by will return ascending, use 'desc' to return descending
	▪	Nulls: Nulls can be specifically addressed after the rest of the order by statement
	⁃	Example: SELECT * FROM orders ORDER BY status NULLS FIRST

Data Types and Casting values
Sometimes columns 'type' doesn't match what you're evaluating, for this use CAST
	Note: By default cast will round for you
	CAST(<column/result> AS <type>)
	<column/result>::<type>
	Examples
		Select CAST(order_total as int), order_total from orders;
		select order_total::INT, order_total from orders;
	Types: 
	•	numbers: 
	⁃	whole: integer
	⁃	decimal: float
	⁃	Decimal with limited significant values: numeric
	•	text: text
	⁃	Text with maximum size set: varchar(length)
	•	true/false value:  boolean
	•	date objects: 
	⁃	calendar date: date
	⁃	calendar date with specific time: timestamp
	⁃	Calendar date with specific time and timezone:  timestamp without timezone
	•	specific storage of key-value pairs: JSON
	•	set or collection of values that all share same data type: array
	⁃	Ex: collect of whole numbers would be an array of integers where the type for all values in the collection (array) are all integers

Aggregate functions 
If you select any columns/values that are not aggregate functions, 
   these will require a 'group by' clause to group the results and be able to perform the function results.

Average: returns average of the total of the column or the calculation.  
	AVG(<column/calculation>) 
	note: null values are not included in denominator 
	Example: SELECT avg(order_total) FROM orders;
Addition: returns the sum of the total of the column or calculation
	SUM(<column/calculation>)
           non-aggregate function to get by row addition: <column> + <column>  
				-- Note: if either column value is null, the result will be null
Count: returns the total number of rows where the column or value is not null
	COUNT(<column/value>)
	COUNT(DISTINCT <column/value>) -- Will only count unique values of the column
Minimum and Maximum: returns the minimum or maximum value of the rows for that column/calculation
	MAX(<column/value>), MIN(<column/value>)
	Examples:
		Select max(order_total) as max_order, min(order_total) as min_order from orders;

Date Select Functions
	EXTRACT(Value From <date/timestamp>)
      Examples:
SELECT
EXTRACT(year from created_at) as year,
EXTRACT(month from created_at) as month,
EXTRACT(week from created_at) as week,
EXTRACT(day from created_at) as day
FROM orders LIMIT 10;

now()  -- return the current timestamp of the database server
	Interval -- Manipulate dates by adding or subtracting intervals of dates
		interval '1 month', interval 2 days', interval '4 weeks', interval '1 year'
		Example:
			SELECT * FROM orders 
			WHERE now() - interval '1 month'


CASE STATEMENTS
Top use: Create a classification resulting column of data based on data in the table. 

Less often: input to the case statement a column or value you want to evaluate the exact value of..
CASE <column/calculation> WHEN <result>       THEN <value when exact match> WHEN <result2>       THEN <value when exact match> … ELSE      <default value> END

Example: 
SELECT 
CASE coalesce(status,'') -- make the null status an blank text instead
WHEN 'complete' then 'shipped'  -- This will 
WHEN 'ready to ship' then 'not shipped'
WHEN 'order confirmed' then 'not shipped'
WHEN '' then 'not shipped'  -- since we converted all nulls to empty string, I just check for the empty string here
ELSE 'unknown status' END
FROM orders
GROUP BY 1 -- note you can group by the resulting case statement

Most often used: You can use this version to get the same 
CASE  WHEN <true/false result>       THEN <value when true> WHEN <true/false result>       THEN <value when true>… ELSE        <default value> END
Example:
SELECT CASE 
WHEN status in ('complete','shipped') then 'shipped'
WHEN status in ('ready to ship', 'order confirmed') or status IS NULL then 'not shipped'
ELSE 'unknown status' END
FROM orders 
GROUP BY 1

Filtering
Filter: Requires using 'WHERE' 
	WHERE <true/false evaluation/result> 

>, <, =  -- use less than, greater than and equal to filter numbers
!= , <>   -- use this for “not equal” 

and/or: Add additional clauses to your filter to either further restrict or expand the results
WHERE <true/false evaluation1> 
AND <true/false evaluation2> 
AND (<true/false evaluation3> OR <true/false evaluation4> )
Example: 
SELECT * FROM orders
WHERE status IS NOT NULL
AND created_at > '2018-01-01'
AND (order_total > 10.0 OR shipping_total > 10.0) -- grab any orders with either order or shipping total over 10
Nulls note: If a value being evaluated is null, the results will ONLY be included when specified to include nulls
	Example:
		SELECT * from orders where status IS NULL
		SELECT * from orders where status in ('ready to ship', 'order confirmed') OR status IS NULL

Text
	like and ilike - match a string using '%' to identify where any set of characters/words is acceptable
	like -- matches the case exactly
	ilike -- will ignore case when matching
	Examples: (return same results/rows)
		SELECT * from product_types WHERE name like '%clothing' 
		SELECT * from product_types WHERE name ilike '%cLoThInG'

	~ and ~* -- match the text anywhere in the column/value
	~             -- matches case exactly
	~*           -- will ignore case when matching
	Examples: (results will be equivalent to the (i)like statements above)
		SELECT * from product_types WHERE name ~ 'clothing' 
		SELECT * from product_types WHERE name ~* 'cLoThInG'

Date Filter Functions
>, <, =  -- use less than, greater than and equal to filter by date strings
Example: get any data from 2017
	Select * from orders where created_at >= '2017-01-01' and created_at < '2018-01-01'
Between -- use Between to be less redundant with dates
	Select * from orders where created_at BETWEEN '2017-01-01' and '2018-01-01'


Set Operators
Union - return the unique set of rows unioned together. Columns of results being united must match
Example: 
	SELECT product_id from order_products
	UNION
	SELECT product_id from cart_products

Intersect - return the unique set of rows in the primary results AND in the secondary results
Example:  get products that are currently in a cart and have been ordered in the past
	SELECT product_id  from order_products
	INTERSECT
	SELECT product_id from cart_products

Except - return the unique set of rows in the primary results NOT in the secondary results
Example: products not currently in any carts
	SELECT id as product_id FROM products
	EXCEPT
	SELECT product_id FROM cart_products

Joins
Joins will align the values of two tables to form a single set of results with columns from both tables. 
Using a join requires giving it a clause to use to define how it will pull the data together

Joining  - There are two ways to give join the clause: using ON, and using WHERE
	SELECT * FROM products p
	JOIN product_types pt ON pt.id = p.product_type_id   -- define that we want results aligned on product_type for the product

	SELECT * FROM products p
	JOIN product_types pt 
	WHERE pt.id = p.product_type_id    -- define that we want results aligned on product_type for the product

Inner Join - return rows from both tables where the joined values match on the clause given, JOIN without other indicators is by default an Inner join
	Example: Identical to before
	SELECT * FROM products p
	INNER JOIN product_types pt ON pt.id = p.product_type_id   -- define that we want results aligned on product_type for the product

outer join - return all rows from the primary table, fill in all values for secondary table that don’t match the primary with null values (otherwise same as inner join)
	Left outer join will select the table that is first declared as the primary table
	Right outer join will select the table being joined to the first declared table as the primary table
	Example: this will pull all rows from products and fill in cart_product values for those that don’t match
		SELECT * FROM products p
		LEFT OUTER JOIN cart_products cp on cp.product_id = p.id
	Example: This will pull all rows from 
	
full outer join - return all rows from all tables and fill in any unmatched rows with
SELECT * FROM orders o FULL OUTER JOIN users on o.user_id = u.id 

Table Creation:
Create table based on a query
	Creating tables: SELECT ... INTO and CREATE TABLE AS ... 
	Create a table that will remain in the database based on a query

	Example: Creating an addresses table 
		SELECT address INTO addresses FROM users;
		CREATE TABLE addresses AS SELECT address FROM users;

Create Table 
	CREATE TABLE special_partner_products
	( id integer PRIMARY KEY,
	  partner_name text,
 	 product_name text, 
 	 product_cost float,
 	 product_purchase_date date,
 	 sponsored_user_id integer
	);



